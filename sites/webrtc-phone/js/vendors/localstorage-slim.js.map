{"version":3,"sources":["webpack://ls/webpack/universalModuleDefinition","webpack://ls/webpack/bootstrap","webpack://ls/webpack/runtime/define property getters","webpack://ls/webpack/runtime/hasOwnProperty shorthand","webpack://ls/./src/helpers.ts","webpack://ls/./src/ls.ts"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","NOOP","args","isObject","item","constructor","name","hasLS","supportsLS","undefined","localStorage","e","flush","APX","String","fromCharCode","obfus","str","encrypt","JSON","stringify","map","x","charCodeAt","join","parse","config","ttl","encrypter","decrypter","secret","force","keys","forEach","getItem","Date","now","removeItem","set","value","localConfig","_conf","val","setItem","hasTTL","decrypt","clear","remove"],"mappings":"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","file":"localstorage-slim.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ls\"] = factory();\n\telse\n\t\troot[\"ls\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const NOOP = (...args: unknown[]): unknown => undefined;\n\nexport const escapeRegExp = (text: string): string => text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nexport const isObject = (item: any): boolean => {\n  return item !== null && item.constructor.name === 'Object';\n};\n","/*\n * https://github.com/niketpathak/localstorage-slim\n * Copyright (c) 2021 Niket Pathak\n * MIT License\n */\n\nimport { isObject, NOOP } from './helpers';\nimport type { Encrypter, Decrypter, LocalStorageConfig } from './types';\n\n// private flags\nlet hasLS: boolean;\n\nconst supportsLS = (): boolean => {\n  if (hasLS !== undefined) return hasLS;\n  hasLS = true;\n\n  try {\n    if (!localStorage) {\n      hasLS = false;\n    }\n  } catch (e) {\n    // some browsers throw an error if you try to access local storage (e.g. brave browser)\n    // and some like Safari do not allow access to LS in incognito mode\n    hasLS = false;\n  }\n\n  // flush once on init\n  flush();\n\n  return hasLS;\n};\n\n// Apex\nconst APX = String.fromCharCode(0);\n\n// tiny obsfuscator\nconst obfus: Encrypter | Decrypter = (str, key, encrypt = true) =>\n  encrypt\n    ? [...((JSON.stringify(str) as unknown) as string[])]\n      .map((x) => String.fromCharCode(x.charCodeAt(0) + (key as number)))\n      .join('')\n    : JSON.parse([...(str as string[])].map((x) => String.fromCharCode(x.charCodeAt(0) - (key as number))).join(''));\n\nconst decrypter: Decrypter = (str, key) => {\n  return obfus(str, key, false);\n};\n\nconst config: LocalStorageConfig = {\n  ttl: null,\n  encrypt: false,\n  encrypter: obfus,\n  decrypter,\n  secret: 75,\n};\n\nconst set = <T = unknown>(key: string, value: T, localConfig: LocalStorageConfig = {}): void | boolean => {\n  if (!supportsLS()) return false;\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  try {\n    let val = _conf.ttl && _conf.ttl > 0 ? { [APX]: value, ttl: Date.now() + _conf.ttl * 1e3 } : value;\n\n    if (_conf.encrypt) {\n      // if ttl exists, only encrypt the value\n      if (_conf.ttl && APX in (val as Record<string, unknown>)) {\n        (val as Record<string, unknown>)[APX] = (_conf.encrypter || NOOP)(\n          (val as Record<string, unknown>)[APX],\n          _conf.secret\n        ) as string;\n      } else {\n        val = (_conf.encrypter || NOOP)(val, _conf.secret) as T;\n      }\n    }\n\n    localStorage.setItem(key, JSON.stringify(val));\n  } catch (e) {\n    // Sometimes stringify fails due to circular refs\n    return false;\n  }\n};\n\nconst get = <T = unknown>(key: string, localConfig: LocalStorageConfig = {}): T | null => {\n  if (!supportsLS()) return null;\n\n  const str = localStorage.getItem(key);\n\n  if (!str) {\n    return null;\n  }\n\n  const _conf = {\n    ...config,\n    ...localConfig,\n    encrypt: localConfig.encrypt === false ? false : localConfig.encrypt || config.encrypt,\n    ttl: localConfig.ttl === null ? null : localConfig.ttl || config.ttl,\n  };\n\n  let item = JSON.parse(str);\n  const hasTTL = isObject(item) && APX in item;\n\n  if (_conf.decrypt || _conf.encrypt) {\n    try {\n      if (hasTTL) {\n        item[APX] = (_conf.decrypter || NOOP)(item[APX], _conf.secret) as string;\n      } else {\n        item = (_conf.decrypter || NOOP)(item, _conf.secret) as string;\n      }\n    } catch (e) {\n      // Either the secret is incorrect or there was a parsing error\n      // do nothing [returns the encrypted/unparsed value]\n    }\n  }\n\n  // if not using ttl, return immediately\n  if (!hasTTL) {\n    return item;\n  }\n\n  if (Date.now() > item.ttl) {\n    localStorage.removeItem(key);\n    return null;\n  }\n\n  return item[APX];\n};\n\nconst flush = (force = false): false | void => {\n  if (!supportsLS()) return false;\n  Object.keys(localStorage).forEach((key) => {\n    const str = localStorage.getItem(key);\n    if (!str) return; // continue iteration\n    let item;\n    try {\n      item = JSON.parse(str);\n    } catch (e) {\n      // Some packages write strings to localStorage that are not converted by JSON.stringify(), so we need to ignore it\n      return;\n    }\n    // flush only if ttl was set and is/is not expired\n    if (isObject(item) && APX in item && (Date.now() > item.ttl || force)) {\n      localStorage.removeItem(key);\n    }\n  });\n};\n\nconst remove = (key: string): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.removeItem(key);\n};\n\nconst clear = (): undefined | false => {\n  if (!supportsLS()) return false;\n  localStorage.clear();\n};\n\nexport default {\n  config,\n  set,\n  get,\n  flush,\n  clear,\n  remove,\n};\n"],"sourceRoot":""}